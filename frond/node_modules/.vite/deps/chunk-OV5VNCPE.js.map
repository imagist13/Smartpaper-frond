{
  "version": 3,
  "sources": ["../../web-namespaces/index.js", "../../hast-util-parse-selector/lib/index.js", "../../hastscript/lib/create-h.js", "../../hastscript/lib/svg-case-sensitive-tag-names.js", "../../hastscript/lib/index.js"],
  "sourcesContent": ["/**\r\n * Map of web namespaces.\r\n *\r\n * @type {Record<string, string>}\r\n */\r\nexport const webNamespaces = {\r\n  html: 'http://www.w3.org/1999/xhtml',\r\n  mathml: 'http://www.w3.org/1998/Math/MathML',\r\n  svg: 'http://www.w3.org/2000/svg',\r\n  xlink: 'http://www.w3.org/1999/xlink',\r\n  xml: 'http://www.w3.org/XML/1998/namespace',\r\n  xmlns: 'http://www.w3.org/2000/xmlns/'\r\n}\r\n", "/**\r\n * @typedef {import('hast').Element} Element\r\n * @typedef {import('hast').Properties} Properties\r\n */\r\n\r\n/**\r\n * @template {string} SimpleSelector\r\n *   Selector type.\r\n * @template {string} DefaultTagName\r\n *   Default tag name.\r\n * @typedef {(\r\n *   SimpleSelector extends ''\r\n *     ? DefaultTagName\r\n *     : SimpleSelector extends `${infer TagName}.${infer Rest}`\r\n *     ? ExtractTagName<TagName, DefaultTagName>\r\n *     : SimpleSelector extends `${infer TagName}#${infer Rest}`\r\n *     ? ExtractTagName<TagName, DefaultTagName>\r\n *     : SimpleSelector extends string\r\n *     ? SimpleSelector\r\n *     : DefaultTagName\r\n * )} ExtractTagName\r\n *   Extract tag name from a simple selector.\r\n */\r\n\r\nconst search = /[#.]/g\r\n\r\n/**\r\n * Create a hast element from a simple CSS selector.\r\n *\r\n * @template {string} Selector\r\n *   Type of selector.\r\n * @template {string} [DefaultTagName='div']\r\n *   Type of default tag name (default: `'div'`).\r\n * @param {Selector | null | undefined} [selector]\r\n *   Simple CSS selector (optional).\r\n *\r\n *   Can contain a tag name (`foo`), classes (`.bar`), and an ID (`#baz`).\r\n *   Multiple classes are allowed.\r\n *   Uses the last ID if multiple IDs are found.\r\n * @param {DefaultTagName | null | undefined} [defaultTagName='div']\r\n *   Tag name to use if `selector` does not specify one (default: `'div'`).\r\n * @returns {Element & {tagName: ExtractTagName<Selector, DefaultTagName>}}\r\n *   Built element.\r\n */\r\nexport function parseSelector(selector, defaultTagName) {\r\n  const value = selector || ''\r\n  /** @type {Properties} */\r\n  const props = {}\r\n  let start = 0\r\n  /** @type {string | undefined} */\r\n  let previous\r\n  /** @type {string | undefined} */\r\n  let tagName\r\n\r\n  while (start < value.length) {\r\n    search.lastIndex = start\r\n    const match = search.exec(value)\r\n    const subvalue = value.slice(start, match ? match.index : value.length)\r\n\r\n    if (subvalue) {\r\n      if (!previous) {\r\n        tagName = subvalue\r\n      } else if (previous === '#') {\r\n        props.id = subvalue\r\n      } else if (Array.isArray(props.className)) {\r\n        props.className.push(subvalue)\r\n      } else {\r\n        props.className = [subvalue]\r\n      }\r\n\r\n      start += subvalue.length\r\n    }\r\n\r\n    if (match) {\r\n      previous = match[0]\r\n      start++\r\n    }\r\n  }\r\n\r\n  return {\r\n    type: 'element',\r\n    // @ts-expect-error: tag name is parsed.\r\n    tagName: tagName || defaultTagName || 'div',\r\n    properties: props,\r\n    children: []\r\n  }\r\n}\r\n", "/**\r\n * @import {Element, Nodes, RootContent, Root} from 'hast'\r\n * @import {Info, Schema} from 'property-information'\r\n */\r\n\r\n/**\r\n * @typedef {Array<Nodes | PrimitiveChild>} ArrayChildNested\r\n *   List of children (deep).\r\n */\r\n\r\n/**\r\n * @typedef {Array<ArrayChildNested | Nodes | PrimitiveChild>} ArrayChild\r\n *   List of children.\r\n */\r\n\r\n/**\r\n * @typedef {Array<number | string>} ArrayValue\r\n *   List of property values for space- or comma separated values (such as `className`).\r\n */\r\n\r\n/**\r\n * @typedef {ArrayChild | Nodes | PrimitiveChild} Child\r\n *   Acceptable child value.\r\n */\r\n\r\n/**\r\n * @typedef {number | string | null | undefined} PrimitiveChild\r\n *   Primitive children, either ignored (nullish), or turned into text nodes.\r\n */\r\n\r\n/**\r\n * @typedef {boolean | number | string | null | undefined} PrimitiveValue\r\n *   Primitive property value.\r\n */\r\n\r\n/**\r\n * @typedef {Record<string, PropertyValue | Style>} Properties\r\n *   Acceptable value for element properties.\r\n */\r\n\r\n/**\r\n * @typedef {ArrayValue | PrimitiveValue} PropertyValue\r\n *   Primitive value or list value.\r\n */\r\n\r\n/**\r\n * @typedef {Element | Root} Result\r\n *   Result from a `h` (or `s`) call.\r\n */\r\n\r\n/**\r\n * @typedef {number | string} StyleValue\r\n *   Value for a CSS style field.\r\n */\r\n\r\n/**\r\n * @typedef {Record<string, StyleValue>} Style\r\n *   Supported value of a `style` prop.\r\n */\r\n\r\nimport {parse as parseCommas} from 'comma-separated-tokens'\r\nimport {parseSelector} from 'hast-util-parse-selector'\r\nimport {find, normalize} from 'property-information'\r\nimport {parse as parseSpaces} from 'space-separated-tokens'\r\n\r\n/**\r\n * @param {Schema} schema\r\n *   Schema to use.\r\n * @param {string} defaultTagName\r\n *   Default tag name.\r\n * @param {ReadonlyArray<string> | undefined} [caseSensitive]\r\n *   Case-sensitive tag names (default: `undefined`).\r\n * @returns\r\n *   `h`.\r\n */\r\nexport function createH(schema, defaultTagName, caseSensitive) {\r\n  const adjust = caseSensitive ? createAdjustMap(caseSensitive) : undefined\r\n\r\n  /**\r\n   * Hyperscript compatible DSL for creating virtual hast trees.\r\n   *\r\n   * @overload\r\n   * @param {null | undefined} [selector]\r\n   * @param {...Child} children\r\n   * @returns {Root}\r\n   *\r\n   * @overload\r\n   * @param {string} selector\r\n   * @param {Properties} properties\r\n   * @param {...Child} children\r\n   * @returns {Element}\r\n   *\r\n   * @overload\r\n   * @param {string} selector\r\n   * @param {...Child} children\r\n   * @returns {Element}\r\n   *\r\n   * @param {string | null | undefined} [selector]\r\n   *   Selector.\r\n   * @param {Child | Properties | null | undefined} [properties]\r\n   *   Properties (or first child) (default: `undefined`).\r\n   * @param {...Child} children\r\n   *   Children.\r\n   * @returns {Result}\r\n   *   Result.\r\n   */\r\n  function h(selector, properties, ...children) {\r\n    /** @type {Result} */\r\n    let node\r\n\r\n    if (selector === null || selector === undefined) {\r\n      node = {type: 'root', children: []}\r\n      // Properties are not supported for roots.\r\n      const child = /** @type {Child} */ (properties)\r\n      children.unshift(child)\r\n    } else {\r\n      node = parseSelector(selector, defaultTagName)\r\n      // Normalize the name.\r\n      const lower = node.tagName.toLowerCase()\r\n      const adjusted = adjust ? adjust.get(lower) : undefined\r\n      node.tagName = adjusted || lower\r\n\r\n      // Handle properties.\r\n      if (isChild(properties)) {\r\n        children.unshift(properties)\r\n      } else {\r\n        for (const [key, value] of Object.entries(properties)) {\r\n          addProperty(schema, node.properties, key, value)\r\n        }\r\n      }\r\n    }\r\n\r\n    // Handle children.\r\n    for (const child of children) {\r\n      addChild(node.children, child)\r\n    }\r\n\r\n    if (node.type === 'element' && node.tagName === 'template') {\r\n      node.content = {type: 'root', children: node.children}\r\n      node.children = []\r\n    }\r\n\r\n    return node\r\n  }\r\n\r\n  return h\r\n}\r\n\r\n/**\r\n * Check if something is properties or a child.\r\n *\r\n * @param {Child | Properties} value\r\n *   Value to check.\r\n * @returns {value is Child}\r\n *   Whether `value` is definitely a child.\r\n */\r\nfunction isChild(value) {\r\n  // Never properties if not an object.\r\n  if (value === null || typeof value !== 'object' || Array.isArray(value)) {\r\n    return true\r\n  }\r\n\r\n  // Never node without `type`; thatâ€™s the main discriminator.\r\n  if (typeof value.type !== 'string') return false\r\n\r\n  // Slower check: never property value if object or array with\r\n  // non-number/strings.\r\n  const record = /** @type {Record<string, unknown>} */ (value)\r\n  const keys = Object.keys(value)\r\n\r\n  for (const key of keys) {\r\n    const value = record[key]\r\n\r\n    if (value && typeof value === 'object') {\r\n      if (!Array.isArray(value)) return true\r\n\r\n      const list = /** @type {ReadonlyArray<unknown>} */ (value)\r\n\r\n      for (const item of list) {\r\n        if (typeof item !== 'number' && typeof item !== 'string') {\r\n          return true\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // Also see empty `children` as a node.\r\n  if ('children' in value && Array.isArray(value.children)) {\r\n    return true\r\n  }\r\n\r\n  // Default to properties, someone can always pass an empty object,\r\n  // put `data: {}` in a node,\r\n  // or wrap it in an array.\r\n  return false\r\n}\r\n\r\n/**\r\n * @param {Schema} schema\r\n *   Schema.\r\n * @param {Properties} properties\r\n *   Properties object.\r\n * @param {string} key\r\n *   Property name.\r\n * @param {PropertyValue | Style} value\r\n *   Property value.\r\n * @returns {undefined}\r\n *   Nothing.\r\n */\r\nfunction addProperty(schema, properties, key, value) {\r\n  const info = find(schema, key)\r\n  /** @type {PropertyValue} */\r\n  let result\r\n\r\n  // Ignore nullish and NaN values.\r\n  if (value === null || value === undefined) return\r\n\r\n  if (typeof value === 'number') {\r\n    // Ignore NaN.\r\n    if (Number.isNaN(value)) return\r\n\r\n    result = value\r\n  }\r\n  // Booleans.\r\n  else if (typeof value === 'boolean') {\r\n    result = value\r\n  }\r\n  // Handle list values.\r\n  else if (typeof value === 'string') {\r\n    if (info.spaceSeparated) {\r\n      result = parseSpaces(value)\r\n    } else if (info.commaSeparated) {\r\n      result = parseCommas(value)\r\n    } else if (info.commaOrSpaceSeparated) {\r\n      result = parseSpaces(parseCommas(value).join(' '))\r\n    } else {\r\n      result = parsePrimitive(info, info.property, value)\r\n    }\r\n  } else if (Array.isArray(value)) {\r\n    result = [...value]\r\n  } else {\r\n    result = info.property === 'style' ? style(value) : String(value)\r\n  }\r\n\r\n  if (Array.isArray(result)) {\r\n    /** @type {Array<number | string>} */\r\n    const finalResult = []\r\n\r\n    for (const item of result) {\r\n      // Assume no booleans in array.\r\n      finalResult.push(\r\n        /** @type {number | string} */ (\r\n          parsePrimitive(info, info.property, item)\r\n        )\r\n      )\r\n    }\r\n\r\n    result = finalResult\r\n  }\r\n\r\n  // Class names (which can be added both on the `selector` and here).\r\n  if (info.property === 'className' && Array.isArray(properties.className)) {\r\n    // Assume no booleans in `className`.\r\n    result = properties.className.concat(\r\n      /** @type {Array<number | string> | number | string} */ (result)\r\n    )\r\n  }\r\n\r\n  properties[info.property] = result\r\n}\r\n\r\n/**\r\n * @param {Array<RootContent>} nodes\r\n *   Children.\r\n * @param {Child} value\r\n *   Child.\r\n * @returns {undefined}\r\n *   Nothing.\r\n */\r\nfunction addChild(nodes, value) {\r\n  if (value === null || value === undefined) {\r\n    // Empty.\r\n  } else if (typeof value === 'number' || typeof value === 'string') {\r\n    nodes.push({type: 'text', value: String(value)})\r\n  } else if (Array.isArray(value)) {\r\n    for (const child of value) {\r\n      addChild(nodes, child)\r\n    }\r\n  } else if (typeof value === 'object' && 'type' in value) {\r\n    if (value.type === 'root') {\r\n      addChild(nodes, value.children)\r\n    } else {\r\n      nodes.push(value)\r\n    }\r\n  } else {\r\n    throw new Error('Expected node, nodes, or string, got `' + value + '`')\r\n  }\r\n}\r\n\r\n/**\r\n * Parse a single primitives.\r\n *\r\n * @param {Info} info\r\n *   Property information.\r\n * @param {string} name\r\n *   Property name.\r\n * @param {PrimitiveValue} value\r\n *   Property value.\r\n * @returns {PrimitiveValue}\r\n *   Property value.\r\n */\r\nfunction parsePrimitive(info, name, value) {\r\n  if (typeof value === 'string') {\r\n    if (info.number && value && !Number.isNaN(Number(value))) {\r\n      return Number(value)\r\n    }\r\n\r\n    if (\r\n      (info.boolean || info.overloadedBoolean) &&\r\n      (value === '' || normalize(value) === normalize(name))\r\n    ) {\r\n      return true\r\n    }\r\n  }\r\n\r\n  return value\r\n}\r\n\r\n/**\r\n * Serialize a `style` object as a string.\r\n *\r\n * @param {Style} styles\r\n *   Style object.\r\n * @returns {string}\r\n *   CSS string.\r\n */\r\nfunction style(styles) {\r\n  /** @type {Array<string>} */\r\n  const result = []\r\n\r\n  for (const [key, value] of Object.entries(styles)) {\r\n    result.push([key, value].join(': '))\r\n  }\r\n\r\n  return result.join('; ')\r\n}\r\n\r\n/**\r\n * Create a map to adjust casing.\r\n *\r\n * @param {ReadonlyArray<string>} values\r\n *   List of properly cased keys.\r\n * @returns {Map<string, string>}\r\n *   Map of lowercase keys to uppercase keys.\r\n */\r\nfunction createAdjustMap(values) {\r\n  /** @type {Map<string, string>} */\r\n  const result = new Map()\r\n\r\n  for (const value of values) {\r\n    result.set(value.toLowerCase(), value)\r\n  }\r\n\r\n  return result\r\n}\r\n", "/**\r\n * List of case-sensitive SVG tag names.\r\n *\r\n * @type {ReadonlyArray<string>}\r\n */\r\nexport const svgCaseSensitiveTagNames = [\r\n  'altGlyph',\r\n  'altGlyphDef',\r\n  'altGlyphItem',\r\n  'animateColor',\r\n  'animateMotion',\r\n  'animateTransform',\r\n  'clipPath',\r\n  'feBlend',\r\n  'feColorMatrix',\r\n  'feComponentTransfer',\r\n  'feComposite',\r\n  'feConvolveMatrix',\r\n  'feDiffuseLighting',\r\n  'feDisplacementMap',\r\n  'feDistantLight',\r\n  'feDropShadow',\r\n  'feFlood',\r\n  'feFuncA',\r\n  'feFuncB',\r\n  'feFuncG',\r\n  'feFuncR',\r\n  'feGaussianBlur',\r\n  'feImage',\r\n  'feMerge',\r\n  'feMergeNode',\r\n  'feMorphology',\r\n  'feOffset',\r\n  'fePointLight',\r\n  'feSpecularLighting',\r\n  'feSpotLight',\r\n  'feTile',\r\n  'feTurbulence',\r\n  'foreignObject',\r\n  'glyphRef',\r\n  'linearGradient',\r\n  'radialGradient',\r\n  'solidColor',\r\n  'textArea',\r\n  'textPath'\r\n]\r\n", "// Register the JSX namespace on `h`.\r\n/**\r\n * @typedef {import('./jsx-classic.js').Element} h.JSX.Element\r\n * @typedef {import('./jsx-classic.js').ElementChildrenAttribute} h.JSX.ElementChildrenAttribute\r\n * @typedef {import('./jsx-classic.js').IntrinsicAttributes} h.JSX.IntrinsicAttributes\r\n * @typedef {import('./jsx-classic.js').IntrinsicElements} h.JSX.IntrinsicElements\r\n */\r\n\r\n// Register the JSX namespace on `s`.\r\n/**\r\n * @typedef {import('./jsx-classic.js').Element} s.JSX.Element\r\n * @typedef {import('./jsx-classic.js').ElementChildrenAttribute} s.JSX.ElementChildrenAttribute\r\n * @typedef {import('./jsx-classic.js').IntrinsicAttributes} s.JSX.IntrinsicAttributes\r\n * @typedef {import('./jsx-classic.js').IntrinsicElements} s.JSX.IntrinsicElements\r\n */\r\n\r\nimport {html, svg} from 'property-information'\r\nimport {createH} from './create-h.js'\r\nimport {svgCaseSensitiveTagNames} from './svg-case-sensitive-tag-names.js'\r\n\r\n// Note: this explicit type is needed, otherwise TS creates broken types.\r\n/** @type {ReturnType<createH>} */\r\nexport const h = createH(html, 'div')\r\n\r\n// Note: this explicit type is needed, otherwise TS creates broken types.\r\n/** @type {ReturnType<createH>} */\r\nexport const s = createH(svg, 'g', svgCaseSensitiveTagNames)\r\n"],
  "mappings": "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",
  "names": ["h", "value", "parse"]
}
